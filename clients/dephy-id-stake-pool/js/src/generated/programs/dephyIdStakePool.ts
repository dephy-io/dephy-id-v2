/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedCloseNftStakeInstruction,
  type ParsedCreateNftStakeInstruction,
  type ParsedCreateStakePoolInstruction,
  type ParsedDepositTokenInstruction,
  type ParsedInitializeInstruction,
  type ParsedRedeemWithdrawTokenInstruction,
  type ParsedRequestWithdrawTokenInstruction,
  type ParsedUnstakeNftInstruction,
} from '../instructions';

export const DEPHY_ID_STAKE_POOL_PROGRAM_ADDRESS =
  'DeSTKZaWUDGLAx4FFVzMtJPSDTgWi3sccj4MACs9vj6Y' as Address<'DeSTKZaWUDGLAx4FFVzMtJPSDTgWi3sccj4MACs9vj6Y'>;

export enum DephyIdStakePoolAccount {
  AdminAccount,
  NftStakeAccount,
  StakePoolAccount,
  UserStakeAccount,
  WithdrawRequestAccount,
}

export function identifyDephyIdStakePoolAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): DephyIdStakePoolAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([153, 119, 180, 178, 43, 66, 235, 148])
      ),
      0
    )
  ) {
    return DephyIdStakePoolAccount.AdminAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([109, 22, 236, 62, 96, 242, 14, 116])
      ),
      0
    )
  ) {
    return DephyIdStakePoolAccount.NftStakeAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([87, 244, 250, 124, 34, 252, 189, 44])
      ),
      0
    )
  ) {
    return DephyIdStakePoolAccount.StakePoolAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([167, 87, 153, 81, 129, 95, 15, 213])
      ),
      0
    )
  ) {
    return DephyIdStakePoolAccount.UserStakeAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([128, 63, 205, 31, 202, 42, 218, 83])
      ),
      0
    )
  ) {
    return DephyIdStakePoolAccount.WithdrawRequestAccount;
  }
  throw new Error(
    'The provided account could not be identified as a dephyIdStakePool account.'
  );
}

export enum DephyIdStakePoolInstruction {
  CloseNftStake,
  CreateNftStake,
  CreateStakePool,
  DepositToken,
  Initialize,
  RedeemWithdrawToken,
  RequestWithdrawToken,
  UnstakeNft,
}

export function identifyDephyIdStakePoolInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): DephyIdStakePoolInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([254, 163, 164, 157, 253, 253, 83, 23])
      ),
      0
    )
  ) {
    return DephyIdStakePoolInstruction.CloseNftStake;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([107, 143, 248, 220, 223, 135, 171, 100])
      ),
      0
    )
  ) {
    return DephyIdStakePoolInstruction.CreateNftStake;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([198, 175, 88, 63, 128, 43, 8, 214])
      ),
      0
    )
  ) {
    return DephyIdStakePoolInstruction.CreateStakePool;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([11, 156, 96, 218, 39, 163, 180, 19])
      ),
      0
    )
  ) {
    return DephyIdStakePoolInstruction.DepositToken;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
      ),
      0
    )
  ) {
    return DephyIdStakePoolInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([94, 46, 239, 193, 99, 233, 243, 19])
      ),
      0
    )
  ) {
    return DephyIdStakePoolInstruction.RedeemWithdrawToken;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([49, 150, 198, 22, 253, 95, 59, 136])
      ),
      0
    )
  ) {
    return DephyIdStakePoolInstruction.RequestWithdrawToken;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([17, 182, 24, 211, 101, 138, 50, 163])
      ),
      0
    )
  ) {
    return DephyIdStakePoolInstruction.UnstakeNft;
  }
  throw new Error(
    'The provided instruction could not be identified as a dephyIdStakePool instruction.'
  );
}

export type ParsedDephyIdStakePoolInstruction<
  TProgram extends string = 'DeSTKZaWUDGLAx4FFVzMtJPSDTgWi3sccj4MACs9vj6Y',
> =
  | ({
      instructionType: DephyIdStakePoolInstruction.CloseNftStake;
    } & ParsedCloseNftStakeInstruction<TProgram>)
  | ({
      instructionType: DephyIdStakePoolInstruction.CreateNftStake;
    } & ParsedCreateNftStakeInstruction<TProgram>)
  | ({
      instructionType: DephyIdStakePoolInstruction.CreateStakePool;
    } & ParsedCreateStakePoolInstruction<TProgram>)
  | ({
      instructionType: DephyIdStakePoolInstruction.DepositToken;
    } & ParsedDepositTokenInstruction<TProgram>)
  | ({
      instructionType: DephyIdStakePoolInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: DephyIdStakePoolInstruction.RedeemWithdrawToken;
    } & ParsedRedeemWithdrawTokenInstruction<TProgram>)
  | ({
      instructionType: DephyIdStakePoolInstruction.RequestWithdrawToken;
    } & ParsedRequestWithdrawTokenInstruction<TProgram>)
  | ({
      instructionType: DephyIdStakePoolInstruction.UnstakeNft;
    } & ParsedUnstakeNftInstruction<TProgram>);
