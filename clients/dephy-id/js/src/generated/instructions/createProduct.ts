/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { findProductAssetPda } from '../pdas';
import { DEPHY_ID_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  expectSome,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';
import {
  getPluginAuthorityPairDecoder,
  getPluginAuthorityPairEncoder,
  type PluginAuthorityPair,
  type PluginAuthorityPairArgs,
} from '../types';

export const CREATE_PRODUCT_DISCRIMINATOR = new Uint8Array([
  183, 155, 202, 119, 43, 114, 174, 225,
]);

export function getCreateProductDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CREATE_PRODUCT_DISCRIMINATOR
  );
}

export type CreateProductInstruction<
  TProgram extends string = typeof DEPHY_ID_PROGRAM_ADDRESS,
  TAccountVendor extends string | AccountMeta<string> = string,
  TAccountProductAsset extends string | AccountMeta<string> = string,
  TAccountProductAccount extends string | AccountMeta<string> = string,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountMintAuthority extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TAccountMplCore extends
    | string
    | AccountMeta<string> = 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountVendor extends string
        ? ReadonlySignerAccount<TAccountVendor> &
            AccountSignerMeta<TAccountVendor>
        : TAccountVendor,
      TAccountProductAsset extends string
        ? WritableAccount<TAccountProductAsset>
        : TAccountProductAsset,
      TAccountProductAccount extends string
        ? WritableAccount<TAccountProductAccount>
        : TAccountProductAccount,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountMintAuthority extends string
        ? ReadonlyAccount<TAccountMintAuthority>
        : TAccountMintAuthority,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountMplCore extends string
        ? ReadonlyAccount<TAccountMplCore>
        : TAccountMplCore,
      ...TRemainingAccounts,
    ]
  >;

export type CreateProductInstructionData = {
  discriminator: ReadonlyUint8Array;
  name: string;
  uri: string;
  plugins: Option<Array<PluginAuthorityPair>>;
};

export type CreateProductInstructionDataArgs = {
  name: string;
  uri: string;
  plugins: OptionOrNullable<Array<PluginAuthorityPairArgs>>;
};

export function getCreateProductInstructionDataEncoder(): Encoder<CreateProductInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      [
        'plugins',
        getOptionEncoder(getArrayEncoder(getPluginAuthorityPairEncoder())),
      ],
    ]),
    (value) => ({ ...value, discriminator: CREATE_PRODUCT_DISCRIMINATOR })
  );
}

export function getCreateProductInstructionDataDecoder(): Decoder<CreateProductInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      'plugins',
      getOptionDecoder(getArrayDecoder(getPluginAuthorityPairDecoder())),
    ],
  ]);
}

export function getCreateProductInstructionDataCodec(): Codec<
  CreateProductInstructionDataArgs,
  CreateProductInstructionData
> {
  return combineCodec(
    getCreateProductInstructionDataEncoder(),
    getCreateProductInstructionDataDecoder()
  );
}

export type CreateProductAsyncInput<
  TAccountVendor extends string = string,
  TAccountProductAsset extends string = string,
  TAccountProductAccount extends string = string,
  TAccountPayer extends string = string,
  TAccountMintAuthority extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountMplCore extends string = string,
> = {
  /** The authority of the product */
  vendor: TransactionSigner<TAccountVendor>;
  /** This will be created by mpl-core as a collection */
  productAsset?: Address<TAccountProductAsset>;
  productAccount?: Address<TAccountProductAccount>;
  payer: TransactionSigner<TAccountPayer>;
  mintAuthority?: Address<TAccountMintAuthority>;
  systemProgram?: Address<TAccountSystemProgram>;
  mplCore?: Address<TAccountMplCore>;
  name: CreateProductInstructionDataArgs['name'];
  uri: CreateProductInstructionDataArgs['uri'];
  plugins: CreateProductInstructionDataArgs['plugins'];
};

export async function getCreateProductInstructionAsync<
  TAccountVendor extends string,
  TAccountProductAsset extends string,
  TAccountProductAccount extends string,
  TAccountPayer extends string,
  TAccountMintAuthority extends string,
  TAccountSystemProgram extends string,
  TAccountMplCore extends string,
  TProgramAddress extends Address = typeof DEPHY_ID_PROGRAM_ADDRESS,
>(
  input: CreateProductAsyncInput<
    TAccountVendor,
    TAccountProductAsset,
    TAccountProductAccount,
    TAccountPayer,
    TAccountMintAuthority,
    TAccountSystemProgram,
    TAccountMplCore
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  CreateProductInstruction<
    TProgramAddress,
    TAccountVendor,
    TAccountProductAsset,
    TAccountProductAccount,
    TAccountPayer,
    TAccountMintAuthority,
    TAccountSystemProgram,
    TAccountMplCore
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? DEPHY_ID_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    vendor: { value: input.vendor ?? null, isWritable: false },
    productAsset: { value: input.productAsset ?? null, isWritable: true },
    productAccount: { value: input.productAccount ?? null, isWritable: true },
    payer: { value: input.payer ?? null, isWritable: true },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    mplCore: { value: input.mplCore ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.productAsset.value) {
    accounts.productAsset.value = await findProductAssetPda({
      vendor: expectAddress(accounts.vendor.value),
      productName: expectSome(args.name),
    });
  }
  if (!accounts.productAccount.value) {
    accounts.productAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.productAsset.value)),
      ],
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.mplCore.value) {
    accounts.mplCore.value =
      'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d' as Address<'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.vendor),
      getAccountMeta(accounts.productAsset),
      getAccountMeta(accounts.productAccount),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.mintAuthority),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.mplCore),
    ],
    data: getCreateProductInstructionDataEncoder().encode(
      args as CreateProductInstructionDataArgs
    ),
    programAddress,
  } as CreateProductInstruction<
    TProgramAddress,
    TAccountVendor,
    TAccountProductAsset,
    TAccountProductAccount,
    TAccountPayer,
    TAccountMintAuthority,
    TAccountSystemProgram,
    TAccountMplCore
  >);
}

export type CreateProductInput<
  TAccountVendor extends string = string,
  TAccountProductAsset extends string = string,
  TAccountProductAccount extends string = string,
  TAccountPayer extends string = string,
  TAccountMintAuthority extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountMplCore extends string = string,
> = {
  /** The authority of the product */
  vendor: TransactionSigner<TAccountVendor>;
  /** This will be created by mpl-core as a collection */
  productAsset: Address<TAccountProductAsset>;
  productAccount: Address<TAccountProductAccount>;
  payer: TransactionSigner<TAccountPayer>;
  mintAuthority?: Address<TAccountMintAuthority>;
  systemProgram?: Address<TAccountSystemProgram>;
  mplCore?: Address<TAccountMplCore>;
  name: CreateProductInstructionDataArgs['name'];
  uri: CreateProductInstructionDataArgs['uri'];
  plugins: CreateProductInstructionDataArgs['plugins'];
};

export function getCreateProductInstruction<
  TAccountVendor extends string,
  TAccountProductAsset extends string,
  TAccountProductAccount extends string,
  TAccountPayer extends string,
  TAccountMintAuthority extends string,
  TAccountSystemProgram extends string,
  TAccountMplCore extends string,
  TProgramAddress extends Address = typeof DEPHY_ID_PROGRAM_ADDRESS,
>(
  input: CreateProductInput<
    TAccountVendor,
    TAccountProductAsset,
    TAccountProductAccount,
    TAccountPayer,
    TAccountMintAuthority,
    TAccountSystemProgram,
    TAccountMplCore
  >,
  config?: { programAddress?: TProgramAddress }
): CreateProductInstruction<
  TProgramAddress,
  TAccountVendor,
  TAccountProductAsset,
  TAccountProductAccount,
  TAccountPayer,
  TAccountMintAuthority,
  TAccountSystemProgram,
  TAccountMplCore
> {
  // Program address.
  const programAddress = config?.programAddress ?? DEPHY_ID_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    vendor: { value: input.vendor ?? null, isWritable: false },
    productAsset: { value: input.productAsset ?? null, isWritable: true },
    productAccount: { value: input.productAccount ?? null, isWritable: true },
    payer: { value: input.payer ?? null, isWritable: true },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    mplCore: { value: input.mplCore ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.mplCore.value) {
    accounts.mplCore.value =
      'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d' as Address<'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.vendor),
      getAccountMeta(accounts.productAsset),
      getAccountMeta(accounts.productAccount),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.mintAuthority),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.mplCore),
    ],
    data: getCreateProductInstructionDataEncoder().encode(
      args as CreateProductInstructionDataArgs
    ),
    programAddress,
  } as CreateProductInstruction<
    TProgramAddress,
    TAccountVendor,
    TAccountProductAsset,
    TAccountProductAccount,
    TAccountPayer,
    TAccountMintAuthority,
    TAccountSystemProgram,
    TAccountMplCore
  >);
}

export type ParsedCreateProductInstruction<
  TProgram extends string = typeof DEPHY_ID_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** The authority of the product */
    vendor: TAccountMetas[0];
    /** This will be created by mpl-core as a collection */
    productAsset: TAccountMetas[1];
    productAccount: TAccountMetas[2];
    payer: TAccountMetas[3];
    mintAuthority?: TAccountMetas[4] | undefined;
    systemProgram: TAccountMetas[5];
    mplCore: TAccountMetas[6];
  };
  data: CreateProductInstructionData;
};

export function parseCreateProductInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedCreateProductInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 7) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === DEPHY_ID_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      vendor: getNextAccount(),
      productAsset: getNextAccount(),
      productAccount: getNextAccount(),
      payer: getNextAccount(),
      mintAuthority: getNextOptionalAccount(),
      systemProgram: getNextAccount(),
      mplCore: getNextAccount(),
    },
    data: getCreateProductInstructionDataDecoder().decode(instruction.data),
  };
}
